#! /usr/bin/env python
"""
build_cea_adaptive_lut.py

Build an adaptive lut for an equilibrium gas model from the program,
program, CEA2. The CEA interface is the Gas class defined in cea2_gas.py.

For use by the thermodynamics gas model in Eilmer4 - AdaptiveLUT, found 
in dgd/src/gas/adaptive_lut_CEA.d1

The lookup inputs a thermodynamic state defined by density and energy. The 
table stores values to compute the reamining properties. These properties are:
Cv_hat, Cv, R_hat, Cp_hat, gamma_hat.  Also computes trans properties.

Split into sub-programs --build-grid and --write-table

More info, report: 'An adpative look-up table for Eilmer4'

Author: James M. Burgess, 12th Feb 2016
"""
import sys, os, time, numpy, math, inspect, gzip 
import matplotlib.pyplot as plt
from cea2_gas import make_gas_from_name, Gas, list_gas_names

#------------------------------------------------------------------------------#
global vars; vars = 7 # The number of varibles relevant to the gas model used 
                      # (so the code can be re-used for a different model)
def build_function_grid(mygas, jobName, max_lr_splits=5, max_e_splits=9, T_min=200.0,
                        T_max=20000.0, lr_min=-6.0, lr_max=2.0, T_for_offset=302.0):
    """
    Main function of the --build-grid sub-program. Finds the bounds of table,
    determines data points the --write-table program might need, and calls
    CEA to solve the state at those points. Saves the grid to a file.

    :param mygas: gas object used in calling CEA (class def in ceat_gas.py)
    :param jobName: string as a name identifier
    :param max_lr/e_splits: recursion limit of lr/e
    :param T_for_offset: temp of ground-state energy in CEA, needed to convert
       an energy offset, as Eilmer prefers to use 0K as ground.
    :param T/lr_min/max: Range of the table. 
    :returns nothing, but file  'function-grid-<jobName>.py.gz' saved to pwd
    """
    fname = 'function-grid-' + jobName + '.py.gz'
    fp = gzip.open(fname, 'wb')

    print '\n\n\t\t----- Constructing function grid -----'
    print 'CEA is called to create the sample space'
    print 'T_for_offset=', T_for_offset
    global e_offset
    e_offset = get_e_offset(mygas, T_for_offset)
    print 'e_offset=', e_offset

    # log_rho_values used for e_range call - not actual values saved in grid
    log_rho_values = numpy.linspace(log_rho_min, log_rho_max, 50)
    # energy range to represent those temperatures
    e_min, e_max = get_e_range(mygas, T_min, T_max, log_rho_values)

    print 'log-density range = ', log_rho_min, ' : ', log_rho_max, ' log(kg/m^3)'
    print 'temperature range', T_min, ' : ', T_max, ' K'
    print 'computed energy range = ', e_min, ' : ', e_max, ' J/kg (in CEA - not offset)'
    
    # Set the entropy offset condition
    de_min = (e_max - e_min) / max_e_splits
    set_entropy_ref_conds(mygas, e_max, de_min, log_rho_max)

    fp.write("# Auto-generated by build_cea_adaptive_lut.py on: %s\n" % time.asctime())
    fp.write("# Sample grid of CEA data to be used in construction of adaptive lut\n")
    fp.write("%-14g   #p1\n" % p1)
    fp.write("%-14g   #T1\n" % T1)
    fp.write("%-14g   #s1\n" %s1)
    fp.write("%-14g   #e_offset\n" % e_offset)
    fp.write("%-14g   #e_min\n" % (e_min + e_offset))
    fp.write("%-14g   #e_max\n" % (e_max + e_offset))
    fp.write("%-14g   #log_rho_min\n" % log_rho_min)
    fp.write("%-14g   #log_rho_max\n" % log_rho_max)
    fp.write("%-14g   #max_lr_splits\n" % max_lr_splits)
    fp.write("%-14g   #max_e_splits\n" % max_e_splits)


    # Generate the grid points
    ilr = 2**(max_lr_splits)
    ie = 2**(max_e_splits)
    res_factor = 4
    fp.write("%-14g   #ilr\n" % ilr)
    fp.write("%-14g   #ie\n" % ie)
    fp.write("%-14g   #res_fac\n" % res_factor)
    lr_pnts = numpy.linspace(lr_min, lr_max, ilr*3*res_factor + 1)
    e_pnts = numpy.linspace(e_min, e_max, ie*3*res_factor + 1)
    
    for e in e_pnts:
        for lr in lr_pnts:
            # For an alternative source of data, change the CEA_state function
            # to something else
            res = CEA_state(lr, e) 
            fp.write("%10g,\t%10g,\t%10g,\t%10g,\t%10g,\t%10g,\t%10g,\n" %
                      tuple(res[i] for i in range(vars))) # vars is no. vars (7)
            
    fp.close()
    print 'Finished writing grid to file: ', fname

#------------------------------------------------------------------------------#
class Grid:
    """
    Class for reading and indexing the grid that was created by build_function_grid()
    Contains some methodds for reading data from the grid
    """
    def __init__(self, jobName):
        """
        Reads the function grid from a file 'function-grid-<jobName>.py.gz'
        and stores in memory
        :param jobName: Identifier, so that sub-program --write-table knows
            which file to read        
        """
        fname = 'function-grid-' + jobName+ '.py.gz'
        if not os.path.isfile(fname):
            print 'ERROR: File not found containing function grid with name:'
            print 'ERROR: ' + fname 
            print 'ERROR: The program has to run with --build-grid option'
            print 'ERROR: Line number: ', inspect.currentframe().f_lineno 
            exit(1)
        print '\nReading function grid from file:', fname
        
        fp = gzip.open(fname, 'r')
        next(fp); next(fp)
        

        self.p1 = float(fp.readline()[:14])
        self.T1 = float(fp.readline()[:14])  
        self.s1 = float(fp.readline()[:14])
        self.e_offset =  float(fp.readline()[:14])
        self.e_min = float(fp.readline()[:14])
        self.e_max =  float(fp.readline()[:14])
        self.lr_min  = float(fp.readline()[:14])
        self.lr_max =  float(fp.readline()[:14])
        self.max_lr_splits = float(fp.readline()[:14])
        self.max_e_splits = float(fp.readline()[:14])
        if max_lr_splits > self.max_lr_splits or max_e_splits > self.max_e_splits:
            print 'ERROR: Cannot build a table with maximum split settings:'
            print ('ERROR:    log-rho: %d   e: %d' % (max_lr_splits, max_e_splits))
            print 'ERROR: File:', fname,'was constructed with the following settings:'
            print ('ERROR:    log-rho: %d   e: %d' % (self.max_lr_splits, self.max_e_splits))
            print 'ERROR: Must be less than or equal to those settings, or the table ',
            print 'must be reconstructed'
            sys.exit(1)


        # Number of steps if maximum recursion limit reached - actual number 
        # of steps sampled is this factor*3*res_fact
        self.ilr =  float(fp.readline()[:14])
        self.ie =  float(fp.readline()[:14])
        self.res_fact = float(fp.readline()[:14])
        self.dlr_grid = self.lr_max - self.lr_min
        self.de_grid = self.e_max - self.e_min
        
        # Spacing between sample points 
        self.dlr_sample = self.dlr_grid / (self.ilr*3*self.res_fact)   
        self.de_sample = self.de_grid / (self.ie*3*self.res_fact)
        
        # Size of the table can be figured out from the data stored at the top
        self.lr_length =  int( self.ilr*3*self.res_fact + 1 )
        self.e_length =  int( self.ie*3*self.res_fact + 1 )

        # Single array for storing all the data; 3rd dim is for multiple properties
        self.data = numpy.zeros((self.e_length, self.lr_length, vars)) # vars is no. vars (7)

        # Read the file line by line
        for i in range(self.e_length):
            for j in range(self.lr_length):
                line = fp.readline()
                self.data[i,j] =  numpy.array( line.split(',')[:vars] ).astype(float)  # vars is no. vars (7)
        fp.close()
        print 'Finished reading grid from file:', fname

    def get_indices(self, lr, e):
        """
        Method for determining the index in the table of an input property
        The added '0.0001' is to account for any truncation errors
        :param lr/e: input thermo state in log-rho and energy
        :returns ilr/ie: tuple of array indices referring to data for the state
        """

        ilr = int(  (lr - self.lr_min) / self.dlr_grid   * (self.lr_length-1) + 0.00001 )
        ie = int( (e -  self.e_min  )  / self.de_grid    * (self.e_length-1) + 0.00001)

        return ilr, ie

    def get_values(self, lr, e):
        """
        Method for finding the CEA data for an input state by reading from the grid
        :param lr/e: input thermo state in log-rho and energy
        :returns : A 7 element 1-D array of the CEA data for that state        
        """
        ilr, ie = self.get_indices(lr, e)
        return self.data[ie, ilr] 
 
    def index_directly(self, ilr, ie):
        """
        Method for finding CEA data by inputting the array index and not the 
        state. This is useful to the method Patch.error()
        :param ilr/ie: tuple of array indices referring to data for the state
          :returns : A 7 element 1-D array of the CEA data for that state    
        """
        return self.data[ie, ilr]


#------------------------------------------------------------------------------#
class Patch:
    """
    Class defining a rectangular patch of data in log(density)-energy space
    Stores the data for interpolation. Includes methods for computing error
    in the patch and for sub-dividing and returning new patches.
    """
    counter = 0 # Class instance used for patch ID's
    
    def __init__(self, lr_lo, lr_hi, e_lo, e_hi):
        """
    :param ID  = Unique ID for each patch, tracked by the static var 'counter'
    :param lr_lo: log(rho) lower limit; lr_hi: log(rho) upper limit 
    :param e_lo: energy lower limit; e_hi: energy upper limit
    :param splitID = dimension the patch was split - e, lr or n if not split
    :param errs = array of error for each property (max or rms depending on 
        error method selected (by global var, EM)
    :param left/right_patch_ID: ID's of patches resulting from patch been split
    :param props: If interpolation is linear (global var IM='linear'), properties
        of all 7 variables stored at 4 patch corners (be calling grid.get_values func)
    :param bs: If interpolation is bezier (global var IM='bezier'), 16 control 
        points for all 7 vars. Determined by calling get_control_points() method
    :param splits: number of splits - could be used to enforce a split limit.
        """
        self.ID = self.__class__.counter # Assign patch ID
        self.__class__.counter +=1 # Increment the patch ID counter
        
        self.lr_lo = lr_lo
        self.lr_hi = lr_hi
        self.e_lo = e_lo
        self.e_hi = e_hi
        # For linear interpolation, save the CEA data at the patch corners
        if IM == 'linear':
            self.props = numpy.array( [grid.get_values( lr_lo, e_lo),
                                       grid.get_values( lr_hi, e_lo),
                                       grid.get_values( lr_lo, e_hi),
                                       grid.get_values( lr_hi, e_hi) ])
            
        # For Bezier interpolation, we need the control points 
        elif IM == 'bezier':
            self.get_control_points()
            assert hasattr(self, 'bs'), 'Control point array bs not initialised'
        else:
            print 'ERROR: The program should never have reached this point' 
            print 'ERROR: Select valid interpolation method: bezier or linear'
            print 'ERROR: Line number: ', inspect.currentframe().f_lineno 
            sys.exit(1) 
            
        self.errs = None # Temporary arary of property errors
        
        self.splitID = 'n' # no split until it's explicitly changed
        self.splits = 0

        self.left_patchID = -1 # Value if the patch is not split further
        self.right_patchID = -1
        self.split_lr_cnt = 0 # counting the number of splits of each patch
        self.split_e_cnt = 0

    def get_control_points(self):
        """
        If IM='bezier', find control point data (16 evenly spaced points on a grid) 
        :param lr_pnts: 4 lr coords of control points
        :param e_pnts: 4 e coords of control points
        :param fs: array of properties at 16 control points (by calling CEA)
        :param B_inv: Inverse Bezier matrix in bezier patch (see Luke & Collins)
            This matrix is a global var saved at another point in thefile
        :returns bs: 16 control point values in a flattened (1D) array which is 
            more appropriate to write to a file. This is for all 7 properties, so
            the array is actually 16x7.
        """
        lr_pnts = numpy.linspace(self.lr_lo, self.lr_hi, 4)
        e_pnts = numpy.linspace(self.e_lo, self.e_hi, 4)
      
            
        fs = numpy.zeros((16,vars))  # vars is no. vars (7)
        for i in range(4):
            for j in range(4):
                fs[4*i+j] = grid.get_values(lr_pnts[j], e_pnts[i])

        bs = numpy.zeros((16,vars))  # vars is no. vars (7)
        for i in range(16):
            for j in range(16):
                bs[i] += B_inv[i,j]*fs[j]
        self.bs = bs 

    def interpolate(self, lr, e):
        """
        Interpolate 7 properties for a given value of lr, e.
        For linear interpolation method:
        :param lrfrac: log(rho) linear interpolation fraction 
        :param efrac: energy linear interpolation fraction
        :returns result: 1D array of interpolated values (7 properties)

        For bezier interpolation method:
        :param u,v: parametric coordinates of lr,e in the patch
        :param b: Array for implementing the De Casteljau algorithm - 16 control
            points are mapped back to their 4x4 grid, which is nested inside a 4
            element array (on the last element) - this outer array is for the 
            iteration procedure. Each control point has a 7-element array nested
            for the 7 properties
        :returns the conerged result of the De Casteljau algorithm - which is 
            the interpolated value for 7 values (so a 7 element 1D array)
        """
        if IM == 'linear':
            lrfrac = (lr - self.lr_lo) / (self.lr_hi - self.lr_lo)
            efrac = (e - self.e_lo) / (self.e_hi - self.e_lo)
            result = (1.0 - efrac) * (1.0 - lrfrac) * self.props[0] + \
                     (1.0 - efrac) * lrfrac         * self.props[1] + \
                     efrac         * (1.0 - lrfrac) * self.props[2] + \
                     efrac         * lrfrac         * self.props[3]

            return result # Returns a 1D array - 7 properties

        elif IM == 'bezier':
            if not hasattr(self, 'bs'):
                 print 'ERROR: Interpolating requires the control points for the patch'
                 print 'ERROR: Run object method: Patch.get_control_points() '
                 print 'ERROR: Line number: ', inspect.currentframe().f_lineno 
                 sys.exit(1)
            u = (lr - self.lr_lo) / (self.lr_hi - self.lr_lo)
            v = (e - self.e_lo) / (self.e_hi - self.e_lo)
            b = numpy.zeros((4,4,4,vars)) # The last nesting is for the #vars(7) properties
            for i in range(4):
                for j in range(4):
                    b[3,i,j] = self.bs[i*4+j]
                
            for k in range(2,-1,-1):
                for i in range(k+1):
                    for j in range(k+1):
                        b[k,j,i] = (1-u)*(1-v)*b[k+1,j,i]+u*(1-v)*b[k+1,j,i+1]+\
                                   (1-u)*v*b[k+1,j+1,i] + u*v*b[k+1,j+1,i+1];
                      
            return b[0,0,0] 

        else:
            print 'ERROR: The program should never have reached this point' 
            print 'ERROR: select valid interpolation method: bezier or linear'
            print 'ERROR: Line number: ', inspect.currentframe().f_lineno 
            sys.exit(1) 
     
    def error(self):
        """
        Compute a measure of patch error by taking sample points
        
        Sampling:
        Two sets of sample cordinates are created. First - create a grid of 
        spnts^2 (from the global var spnts). Second - grid with separation
        equal to a globally defined min (dlr_sample, de_sample). Whichever
        has the most sample points is chosed - this ensures large patches
        are sampled regularly enough. The minimum sampling only occurs once
        the split count is less than 4. This is because the largest patches
        will be split anyway, and if we sample based on minimum sample size
        for the largest ones, the grids are enormous, and CEA is called up
        to tens of thousands of times for the one patch.

        :param lr_pnts: lr coords of sample points.
        :param e_pnts: e coords of sample points
        :param CEA_results: 7 properties all sample points
        :param interp_results: 7 properties all sample points - by calling 
            interpolation method
        :param error: Relative error at each sample point for each property

        :returns: nothing, but the side-effect is that the patch now has
            errs attribute, containing, for each property, either the max
            or rms error, depending on the global variable, EM.
        """

        # Store the indices of the corners of the patch for making error grid
        ilr_upper, ie_upper = grid.get_indices(self.lr_hi, self.e_hi)
        ilr_lower, ie_lower = grid.get_indices(self.lr_lo, self.e_lo)
        
        step_lr = 1
        step_e = 1
        lim =200 # upper limit on number of points sampled in one dim
        # The following provision is to make sure the number of sample
        # points is not unreasonably high
        while True:
            lr_pnts = numpy.arange(ilr_lower + 1, ilr_upper, step_lr )
            e_pnts = numpy.arange(ie_lower + 1, ie_upper, step_e)
            
            if len(lr_pnts) > lim: step_lr+=1
            if len(e_pnts) > lim: step_e+=1

            if len(lr_pnts) <= lim and len(e_pnts) <= lim:
                break
            
        lr_len = len(lr_pnts)
        e_len = len(e_pnts)
     
        CEA_results = numpy.zeros((lr_len*e_len, vars)) # vars is no. vars (7)
        for i in range(e_len):
            for j in range(lr_len):
                CEA_results[lr_len*i+j] = grid.index_directly(lr_pnts[j], e_pnts[i])
     
        interp_results = numpy.zeros((lr_len*e_len, vars))  # vars is no. vars (7)
        for i in range(e_len):
            for j in range(lr_len):
                # Points matrix only stores indices in the grid. To do inteprolation
                # we need the actual e and lr values 
                e = grid.e_min + grid.de_sample * e_pnts[i]
                lr = grid.lr_min + grid.dlr_sample * lr_pnts[j]
                interp_results[lr_len*i+j]= self.interpolate(lr,e)

        error_array = numpy.absolute((interp_results - CEA_results) / CEA_results )
        
        if EM == 'maximum':
            max_errs = numpy.zeros(vars) # max error for each property
            for i in range(vars):  # vars is no. vars (7)
                max_errs[i] = max(error_array[:,i])
           
            self.errs = max_errs
     
        elif EM == 'rms':
            # if using bezier interpolation, 6 of the sample points are actually 
            # control points, so their error shouldn't be considered in interpolation
            if IM == 'bezier': 
                adj = 9 
            else: 
                adj = 0
            rms_errs = numpy.zeros(vars) # rms error for each property; vars is no. vars (7)
            for i in range(vars):
                for j in range(spnts**2):
                    rms_errs[i] += error_array[j,i]**2
                rms_errs[i] = math.sqrt(rms_errs[i]/ (lr_len*e_len - adj))
            self.errs = rms_errs
        else:
            print 'ERROR: No valid error method has been selected'
            print 'ERROR: Run print_build_parameters(EM = method) where'
            print 'ERROR: method is \'maximum\' or \'rms\' '
            print 'ERROR: Line number: ', inspect.currentframe().f_linen 
            sys.exit(1)

            

    def split_lr(self):
        """  :return 2 new patches by splitting patch in half in lr dimension"""
        lr_split = (self.lr_lo + self.lr_hi) / 2.0
        P1 = Patch(self.lr_lo, lr_split, self.e_lo, self.e_hi)
        P2 = Patch(lr_split, self.lr_hi, self.e_lo, self.e_hi)
        return P1, P2

    def split_e(self):
        """ :return 2 new patches by splitting patch in half in e dimension"""
        e_split = (self.e_lo + self.e_hi) / 2.0
        P1 = Patch(self.lr_lo, self.lr_hi, self.e_lo, e_split)
        P2 = Patch(self.lr_lo, self.lr_hi, e_split, self.e_hi)
        return P1, P2
    
    def dlr(self):
        """ :return patch length in lr """
        return (self.lr_hi - self.lr_lo)
    
    def de(self):
        """ :return patch length in e """
        return (self.e_hi - self.e_lo)

# End Patch class

#-------------------------------------------------------------------------------#      
  
def split_patches(patch, grid, tree):  
    """
    This is a recursive function that does most of the work:

    A patch is passed as a function parameter, and is sent to the split_test 
    function, which tests if the minimum error or minimum patch size limits have
    been reached. If yes, the patch is recorded as not been split (splitID='n')
    and the recursion ends at that patch.

    If split_test returns True, the patch is separately split in lr and in e, 
    and their errors computed. They are passed to slelect_split_direction(). 
    The split direction that returns the greatest reduction in error is retained. 
    Those patches are added to the tree. The split direction in the parent patch
    is recorded. The ID's of the child patches are stored in the parent patch.
    
    The two new child patches are then passed back into split_patches,
    making the function recursive.

    :param grid: Data grid; instance of Grid class
    :param tree: python dictionary holding every patch
    """
    #print 'ID: %s, lr_split_cnt: %s, e_split_cnt: %s ' % (patch.ID, patch.split_lr_cnt,patch.split_e_cnt)
    if patch.ID % plot_freq == 0:
        # Save a copy of the tree every 100th patch
        if not os.path.isdir("./table_progress"):
            os.makedirs("./table_progress")
        plot_table(tree)
        plt.savefig('table_progress/tree-patch-no-' + str(patch.ID), dpi = 200)
        plt.close()  # Free up memory again (problem if making dozens of plots)

    if split_test(patch) == False:
        assert patch.ID in tree 
        patch.splitID = 'n' 
        return    # Stops the recursion

    P1_lr, P2_lr = patch.split_lr()
    P1_lr.splits = patch.splits + 1
    P2_lr.splits = patch.splits + 1
    # Only one of these sets of patches is retained - so they have the same ID
    # So revert the static class counter back by 2
    patch.__class__.counter -= 2 

    P1_e, P2_e = patch.split_e()
    P1_e.splits = patch.splits + 1
    P2_e.splits = patch.splits + 1
    
    split = select_split_direction(patch, P1_lr, P2_lr, P1_e, P2_e)
    if split == 'lr':
        patch.splitID = 'lr'
        # Increment the count of splits in lr from parent patch
        P1_lr.split_lr_cnt = patch.split_lr_cnt +1;  
        P2_lr.split_lr_cnt = patch.split_lr_cnt +1
        # Copy the count of splits in e from parent patch
        P1_lr.split_e_cnt = patch.split_e_cnt; 
        P2_lr.split_e_cnt = patch.split_e_cnt; 
        # Place the new patches in the tree (dictionary)
        tree[P1_lr.ID] = P1_lr
        tree[P2_lr.ID] = P2_lr
        # Tell the parent patch the ID of the new child patches
        patch.left_patchID = P1_lr.ID
        patch.right_patchID = P2_lr.ID
        # Recursively call split_patches for the new child patches
        split_patches(P2_lr, grid, tree)
        split_patches(P1_lr, grid, tree)
        return
    
    elif split == 'e':
        patch.splitID = 'e'
        # Increment the count of splits in e from parent patch
        P1_e.split_e_cnt = patch.split_e_cnt +1
        P2_e.split_e_cnt = patch.split_e_cnt +1
        # Copy the count of splits in lr from parent patch
        P1_e.split_lr_cnt = patch.split_lr_cnt
        P2_e.split_lr_cnt = patch.split_lr_cnt
        # Place the new patches in the tree (dictionary)
        tree[P1_e.ID] = P1_e
        tree[P2_e.ID] = P2_e 
        # Tell the parent patch the ID of the new child patches
        patch.left_patchID = P1_e.ID
        patch.right_patchID = P2_e.ID
        # Recursively call split_patches for the new child patches
        split_patches(P2_e, grid, tree)
        split_patches(P1_e, grid, tree)
        return
    
    else:
        print 'ERROR: The program should never have reached this point' 
        print 'ERROR: Line number: ', inspect.currentframe().f_lineno 
        sys.exit(1)    
        
def split_test(Patch):
    """
    Called by split_patches(). Test for whether a patch passed should be split.
    
    Checks for the existence global variable, error_lim which defines 
    minimum error for each property. Asserts that patch error is computed.
    
    If: Compares errors against minimum error - if it is, returns True (do split)
    
    Else if: first check to see if both patch dimensions are above the minimum 
    patch size limit (defined globally). Do not split if both dimensions are 
    smaller than the limit, and write that patch to a file that records error 
    of patches that were not split despite having too-high error. 
    If, say the lr dimension is below the minimum limit, but not the e dimension,
    then this function returns True, but the test for split_direction will force 
    the next split to be in e.

    Errors not considered  by the command line option have error_lim = 0.0, and
    so will always pass the test

    Else: Return True (do split) if above error limit and minimum size limit.
    """
    try:
        error_lim # Check for existence of error criteria 
    except NameError:
        print 'Array \'error_lim\' must be defined globally for table build'; 
        sys.exit(1)

    result = (Patch.errs <= error_lim) # Compare error to minimum acceptable error

    if result.all() == True: # All errors in the patch are below the error_lim
        return False         # Don't split
    else:  
        # Even if error limit is reached, recursion limit might stop splitting
        if (Patch.split_lr_cnt >= max_lr_splits and Patch.split_e_cnt >= max_e_splits):
            return False # Don't split  
        else:
           return True     # Split


def select_split_direction(Patch, P1_lr, P2_lr, P1_e, P2_e):
    """
    Called by split_patches(). Determines which split direction to execute.
    The two sets of child patches have their error computed. The error criterion
    is somewhat arbitrary - but here it computes the worst relative error of any
    property in the patch. The average of these is taken between the child nodes.
    Whichever split has the smallest average error is retained.

    Also tests to see if one of the dimensions is below the error requirement.

    :param Patch: the parent patch
    :param P1_lr, P2_lr: the child patches of a log-rho split
    :param P1_e, P2_e: the child patches of an e split
    :returns the split direction as a string.
    """   

    P1_lr.error(); P2_lr.error()
    P1_e.error(); P2_e.error()
    P1_lr_worse = max(P1_lr.errs); P2_lr_worse = max(P2_lr.errs)
    P1_e_worse = max(P1_e.errs); P2_e_worse = max(P2_e.errs)
    P_lr_err = 0.5 * (P1_lr_worse + P2_lr_worse)
    P_e_err = 0.5 * (P1_e_worse + P2_e_worse)

    # First test for the log-rho split limit
    if Patch.split_lr_cnt >= max_lr_splits:
        # can assume e-limit has not been reached. Otherwise the split_test()
        # function would have stopped the program getting here
        return 'e'
    if Patch.split_e_cnt >= max_e_splits:
        return 'lr'

    # If cells haven't reached minimum size, split the direction that reduces error
    if P_e_err <= P_lr_err:
        return 'e'
    elif P_lr_err < P_e_err:
        return 'lr'
    else:
        print 'ERROR: The program should never have reached this point' 
        print 'ERROR: Line number: ', inspect.currentframe().f_lineno 
        sys.exit(1)
    return
    
def CEA_state(lr, e):
    """
    Calls CEA for a given value of lr, e, returning the state. This makes use
    of the mygas object from the Gas class imported from cea2_gas. This works
    by writing to a file, which is why this program takes so long to run.

    :returns array of 7 relevant CEA properties used in CFD simulation.
    These are Cv_hat, Cv, R_hat, Cp_hat, gamma_hat, mu, k. The 'hat' are those
    that have taken into account the e_offset (see function get_e_offset).
    """
    rho = math.pow(10.0, lr)
    mygas.set_rhoe(rho , e) # Update gas state
    Cv_hat = (e + e_offset) / mygas.T
    R_hat = mygas.p / (rho * mygas.T)
    gamma_hat = mygas.a * mygas.a / (R_hat * mygas.T)
    Cp_hat = (mygas.s - s1 + R_hat*math.log(mygas.p/p1))/(math.log(mygas.T/T1))
    return numpy.array([Cv_hat, mygas.C_v, R_hat, Cp_hat, gamma_hat,
                        mygas.mu, mygas.k] )

#-------------------------------------------------------------------------------#  

def set_entropy_ref_conds(mygas, emax, de, lrmax):
    """
    Taken from cfcfd3/lib/gas/tools/build-cea-lut.py by PJ, RJG
    :param mygas: Gas object for CEA interface (cea2_gas.py)
    :params emax: max table energy, de: standard table step, lrmax: max log-rho

    :returns nothing, but sets the global reference conditions, p1, s1, T1, 
    These are reference conditions used for  computing Cp_hat

    The Cp_hat calculation (in Cea_State() ) has a divide by log(T/T1), so T1 
    must be a value not found in the table (or there will be a divide by zero).
    """
    global p1, s1, rho1, T1
    rho1 = math.pow(10, lrmax)
    mygas.set_rhoe(rho1, emax + 0.5*de)
    p1 = mygas.p;  s1 = mygas.s; T1 = mygas.T
    return
    
def get_e_offset(mygas, T):
    """
    Taken from cfcfd3/lib/gas/tools/build-cea-lut.py by PJ, RJG

    At a suitably-low value of temperature, compute the energy offset for CEA gas.
    
    :param mygas: cea2 Gas object
    :T: temperature at which to evaluate the offset
    :returns: offset energy to be added to CEA internal energy.
    
    It is convenient to have the reference temperature of 0 degrees K
    for internal energy and enthalpy, so that e = C_v * T, approximately.
    This is quite different to the reference temperature of 298 degrees K
    used by CEA, so we'll compute an offset value and shift the CEA value
    of internal energy by this offset in future.
    """
    mygas.set_pT(100.0e3, T)
    return  mygas.C_v * T - mygas.e

def get_e_range(mygas, T_min, T_max, log_rho_values):
    """
    Taken from cfcfd3/lib/gas/tools/build-cea-lut.py by PJ, RJG

    Scan the boundary of the temperature and density to determine 
    the range of internal that can be comfortably computed by CEA.
    """
    e_values = []
    for log_rho in log_rho_values:
        mygas.set_rhoT(math.pow(10.0,log_rho), T_min)
        e_values.append(mygas.e)
    e_min = max(e_values)
    e_values = []
    for log_rho in log_rho_values:
        mygas.set_rhoT(math.pow(10.0,log_rho), T_max)
        e_values.append(mygas.e)
    e_max = min(e_values)
    return e_min, e_max

def fix_hanging_nodes(tree):
    """
    A hanging node is where, along a patch boundary, the patch is split on one 
    side, but not the other. This leads to some continuity error. To limit that,
    only one hanging node per edge is permitted.
    
    The function calls iterate_through_tree(), which searches each patch for 
    hanging nodes. If a patch has more than one hanging node, it is split in the
    appropriate dimension. This is repeated until a sweep returns no splits.

    At each loop, the table is plotted. plt.show() will show the progress, and
    stall the program till it is closed, so users can track progress.
    """
    split_flag = True
    print '\nSearching for excessive hanging nodes'
    print 'Search will continue until a sweep returns 0 splits'
    loop_count = 0

    # Make sure the directory exists to recod the progrss of fixing hanging nodes
    if not os.path.isdir("./table_progress"):
            os.makedirs("./table_progress")

    while split_flag != False:
        print 'tree length = ', len(tree)
        loop_count += 1
        print 'Executing tree search no.', loop_count, ' to find excessive hanging nodes'
        tree, split_flag = iterate_through_tree(tree)
       
        plot_table(tree)
        plt.savefig('table_progress/hanging-node-fix-iter-' + str(loop_count), dpi = 200)
        
    return tree
                
def iterate_through_tree(tree):
    """
    Called by fix_hanging_nodes. 
    Loop through each patch. For each, loop trhough all the other patches and 
    look for patches sharing a common edge. If there are more than 2 neighbour
    patches on an edge, there are too many hanging nodes. A split is executed 
    on that patch.

    The new patches are stored in a temporary tree, and appended to the existing
    tree at the end (not possible to add to a tree that is been iterated through
    with the loop). The standard housekeeping that split_patches did when adding
    a new patch is also done.

    :returns the updated tree, and split_flag which is False if no splits were
    done. This will halt the function.
    """
    temp_tree = {} # temporary tree to hold additional patches.  We can't add new
                   # patches to a tree while we are iterating through it
    split_flag = False # will remain False if no splits are required
    problem_patches = 0 # Count of how many patches needed subdividing


    lr_split_IDs = []
    e_split_IDs = []
    tree_copy = tree.copy()
    for this_ID, this_patch in tree.iteritems():   # for each patch in the tree
        north_nghbr = 0; south_nghbr = 0  # Count neighbouring patches on sides
        east_nghbr = 0; west_nghbr = 0 

        if this_patch.splitID != 'n': # Only want to apply this test to leaf nodes
            continue

        for ID, patch in tree_copy.iteritems(): # loop through the other patches
            if patch.splitID != 'n': # Again - only testing leaf nodes
                continue
                   
            # Sweep south edge
            if this_patch.e_lo == patch.e_hi:
                if patch.lr_hi <= this_patch.lr_hi and patch.lr_lo >= this_patch.lr_lo:
                    south_nghbr += 1

            # Sweep north edge
            if this_patch.e_hi == patch.e_lo: 
                if patch.lr_hi <= this_patch.lr_hi and patch.lr_lo >= this_patch.lr_lo:
                    north_nghbr += 1        
                    
            # Sweep west edge
            if this_patch.lr_lo == patch.lr_hi:
                if patch.e_hi <= this_patch.e_hi and patch.e_lo >= this_patch.e_lo:
                    west_nghbr += 1
                    
            # Sweep east edge
            if this_patch.lr_hi == patch.lr_lo:
                if patch.e_hi <= this_patch.e_hi and patch.e_lo >= this_patch.e_lo:
                    east_nghbr += 1
                    
        # If the patch needs splitting, do that, and the necessary housekeeping
        if west_nghbr > 2 or east_nghbr > 2:
            # Save the patch ID to be split when this is done
            lr_split_IDs.append(this_patch.ID)
            split_flag = True
            tree[this_ID].splitID = 'e'
            P1_e, P2_e = tree[this_ID].split_e()
            P1_e.error(), P2_e.error()
            temp_tree[P1_e.ID] = P1_e
            temp_tree[P2_e.ID] = P2_e
            tree[this_ID].left_patchID = P1_e.ID # reference to the new child patches
            tree[this_ID].right_patchID = P2_e.ID
            problem_patches += 1
            continue # Not allowed to split in lr and e at once - leads to overlap
       
        if north_nghbr > 2 or south_nghbr > 2: # Execute split for this_patch
            # Save the patch ID to be split when this is done
            lr_split_IDs.append(this_patch.ID)
            split_flag = True
            tree[this_ID].splitID = 'lr'
            P1_lr, P2_lr = tree[this_ID].split_lr()
            P1_lr.error(), P2_lr.error()
            temp_tree[P1_lr.ID] = P1_lr
            temp_tree[P2_lr.ID] = P2_lr
            tree[this_ID].left_patchID = P1_lr.ID # reference to the new child patches
            tree[this_ID].right_patchID = P2_lr.ID
            problem_patches += 1
            continue
    
    tree.update(temp_tree) # add the new patches to the tree
    print 'number of splits required in the last sweep: ', problem_patches
    return tree, split_flag 
   
def plot_table(tree):
    """ Plot the table - only 'leaf node' in the tree that weren't split"""
    for ID, patch in tree.iteritems():
        if patch.splitID == 'n': # if the patch was not split
            plt.plot([patch.lr_lo, patch.lr_lo, patch.lr_hi, patch.lr_hi, patch.lr_lo], 
                     [patch.e_lo, patch.e_hi, patch.e_hi, patch.e_lo, patch.e_lo ], 'k')
#------------------------------------------------------------------------------#

def write_recursion_limit_file_header(fp2):
    """
    The split_patches() function halted patch recursion if a minimum patch size
    was reached, even if the error criteria was not met. These patches and their
    errors are written to a log-file - the user may not want to use it if the 
    error is too high in too many places.
    """
    fp2.write('The following patches were not subdivided as they reached the recursion limit')
    fp2.write('\nThe minimum error requirement (that was not met) was defined: ')
    fp2.write('\nCv_hat : %g, Cv : %g, R_hat : %g, Cp_hat : %g, gamma_hat : %g, mu : %g, k : %g'\
              % tuple(error_lim[i] for i in range(vars)))
    fp2.write('Properties not considered have an error limit of 1')
    fp2.write('\n\n %3s %5s %5s %5s %5s %8s %8s %8s %8s %8s\n' %
              ('ID', 'lr_lo', 'lr_hi', 'e_lo', 'e_hi', 'splits',
               'lrsplits', 'esplits', 'splitID', 'error array'))

def write_patch_to_recursion_limit_file(patch, fp2):
    """ See the docstring for write_recursion_limie_file_header() """
    fp2.write("\n%3d %5g %5g %5g %5g" % (patch.ID, patch.lr_lo, patch.lr_hi,
                                               patch.e_lo, patch.e_hi) )
    fp2.write("%8d %8s %s " % (patch.splits, patch.splitID, patch.errs))

#------------------------------------------------------------------------------#
def write_tree_to_file(jobName):
    """
    The main function of the --write-table sub-program. 
    Build the tree and write the interpolation table (tree) to a file to be
    read by LUA.
    Default parameter values are a standard range used for air.
    """
    print '\n\n\t\t----- Constructing table -----'
    print 'Table updates saved to directory: \'./table_progress/\''

    fname = 'cea-adaptive-lut-' + jobName + '.lua.gz'
    fp = gzip.open(fname, 'wb')
    fp.write("-- Auto-generated by build_cea_adaptive_lut.py on: %s\n" % time.asctime())
    fp.write("model = 'CEA adaptive look-up table'\n")
    fp.write("interpolation_method = \'" + IM + "\' \n")
    fp.write("error_method = \'" + EM + "\' \n")
    fp.write("-- error_lim array for respective properties:" +\
             "{Cv_hat, Cv, R_hat, Cp_hat, gamma_hat, mu, k} \n")
    fp.write("error_lim = { %g, %g, %g, %g, %g, %g, %g }\n" % \
             tuple(error_lim[i] for i in range(vars)))  # vars is no. vars (7)
    fp.write("with_entropy = 1\n")
    fp.write("p1 = %g\n" % grid.p1)
    fp.write("T1 = %g\n" % grid.T1)
    fp.write("s1 = %g\n" % grid.s1)
    fp.write("e_offset = %g\n" % grid.e_offset)
    fp.write("emin = %g\n" % (grid.e_min )) # e_offset is applied when writing the grid
    fp.write("emax = %g\n" % (grid.e_max ))
    fp.write("log_rho_min = %g\n" % grid.lr_min)
    fp.write("log_rho_max = %g\n" % grid.lr_max)
    fp.write("max_lr_splits = %d\n" % max_lr_splits)
    fp.write("max_e_splits = %d\n" % max_e_splits)
    
    # Generate the first patch, and put it in the tree 
    first_patch = Patch(grid.lr_min, grid.lr_max, grid.e_min, grid.e_max)
    first_patch.error()
    tree = {}
    tree[first_patch.ID] = first_patch

    # Now call split_patches, which builds the tree 
    split_patches(first_patch, grid, tree)

    # Now fix the hanging nodes problem
    tree = fix_hanging_nodes(tree)
  
    # Write the tree to the file
    fp.write("data_tree = {\n")
    
    # All patches have the basic info of upper and lower bounds, splitID
    # ID of child patches (leaf nodes have this value set to -1)
    for ID, patch in tree.iteritems():
        fp.write("{\n")
        fp.write(" { %d, \'%s\', %d, %d, },\n" % (patch.ID, patch.splitID, patch.left_patchID, 
                                           patch.right_patchID) )
        fp.write(" { %g, %g, %g, %g, }, \n" %  (patch.lr_lo, patch.lr_hi, patch.e_lo, 
                                                patch.e_hi) )
        fp.write(" {")
        if patch.splitID == 'n':
            # Write the patch data for the leaf patches only
            if IM == 'linear':   # Write properties at corners
                for i in range(4):
                    fp.write("\n  {%g, %g, %g, %g, %g, %g, %g}," %\
                              tuple(patch.props[i, j] for j in range(vars)))

            elif IM == 'bezier':   # Write control points 
                for i in range(16):
                    fp.write("\n  {%g, %g, %g, %g, %g, %g, %g}," %\
                              tuple(patch.bs[i, j] for j in range(vars)))
                    
            else:
                print 'ERROR: The program should never have reached this point' 
                print 'ERROR: Line number: ', inspect.currentframe().f_lineno 
                sys.exit(1)  

        fp.write("\n }\n")
        fp.write("},\n\n")
        
    fp.write("}\n\n")
    fp.close()  # main table file
    print 'Finished writing table'
    
    # File for cells not divided due to recursion limit 
    fp2 = gzip.open(jobName+'-recurs-lim-patches.gz', 'wb')
    write_recursion_limit_file_header(fp2)   
    # Count the number of leaf nodes, and check for patches with high error
    child_node_cnt = 0
    recurs_lim_cnt = 0
    for i in range(len(tree)):   # iterate through every patch
        if tree[i].splitID == 'n':
            child_node_cnt += 1
            # Check leaf nodes - if error is not below limit, write to file
            error_result = tree[i].errs <= error_lim
            if error_result.all() != True:
                write_patch_to_recursion_limit_file(tree[i], fp2) 
                recurs_lim_cnt += 1       
    fp2.close() # recursion limit file 
    print 'No. total nodes in tree:', len(tree)
    print 'No. leaf nodes in tree:', child_node_cnt
    print 'No. patches at recursion limit, but above error limit:', recurs_lim_cnt

    # Plot the tree once we are done
    plot_table(tree)
    plt.title(  'cea-adaptive-lut-' + jobName )
    plt.xlabel('$log_{10}(rho)$')
    plt.ylabel('$e$')
    y_max = grid.e_max + 0.1*(grid.e_max - grid.e_min) # to stop the table from been plotted too high
    x_min = grid.lr_min - 0.1*(grid.lr_max - grid.lr_min)
    x_max = grid.lr_max + 0.1*(grid.lr_max - grid.lr_min)
    plt.ylim(0, y_max)
    plt.xlim(x_min, x_max)
    plt.savefig( 'cea-adaptive-lut-' + jobName + '.png')

    return

# The inverse Bezier Matrix - see Luke and Collins. Copied from J.Ho (16x16) 
# dgd/src/nm/tree_patch.d
B_inv = numpy.array(
	[[1.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000,
          0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
          0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000,
          0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000],
	[-0.8333333333333335, 3.0000000000000000, -1.5000000000000000, 0.3333333333333333,
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000,
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000],
	[0.3333333333333334, -1.5000000000000000, 3.0000000000000000, -0.8333333333333333,
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000,
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000,
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000],
	[0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 1.0000000000000000,
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000],
	[-0.8333333333333335, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000,
         3.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
         -1.5000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000,
         0.3333333333333333, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000],
	[0.6944444444444451, -2.5000000000000004, 1.2500000000000002, -0.2777777777777777, 
         -2.5000000000000004, 9.0000000000000000, -4.5000000000000000, 0.9999999999999997,
         1.2500000000000002, -4.5000000000000000, 2.2500000000000000, -0.4999999999999997,
         -0.2777777777777777, 0.9999999999999998, -0.4999999999999997, 0.1111111111111111],
	[-0.2777777777777780, 1.2500000000000002, -2.5000000000000004, 0.6944444444444444,
         1.0000000000000002, -4.5000000000000000, 9.0000000000000000, -2.4999999999999996,
         -0.5000000000000001, 2.2500000000000000, -4.5000000000000000, 1.2499999999999996,
         0.1111111111111111, -0.4999999999999998, 0.9999999999999996, -0.2777777777777777],
	[0.0000000000000000, 0.0000000000000000, 0.0000000000000000, -0.8333333333333335, 
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 3.0000000000000000, 
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, -1.5000000000000000,
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.3333333333333333],
	[0.3333333333333334, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
         -1.5000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
         3.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
         -0.8333333333333333, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000],
	[-0.2777777777777780, 1.0000000000000002, -0.5000000000000001, 0.1111111111111111,
         1.2500000000000002, -4.5000000000000000, 2.2500000000000000, -0.4999999999999998,
         -2.5000000000000004, 9.0000000000000000, -4.5000000000000000, 0.9999999999999996,
         0.6944444444444444, -2.4999999999999996, 1.2499999999999996, -0.2777777777777778],
	[0.1111111111111112, -0.5000000000000001, 1.0000000000000002, -0.2777777777777778, 
         -0.5000000000000001, 2.2500000000000000, -4.5000000000000000, 1.2499999999999996, 
         1.0000000000000002, -4.5000000000000000, 9.0000000000000000, -2.4999999999999991, 
         -0.2777777777777778, 1.2499999999999996, -2.4999999999999991, 0.6944444444444443],
	[0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.3333333333333334, 
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, -1.5000000000000000,
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 3.0000000000000000,
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, -0.8333333333333333],
	[0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000,
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
         1.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000],
	[0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000,
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
         -0.8333333333333335, 3.0000000000000000, -1.5000000000000000, 0.3333333333333333],
	[0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000,
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000,
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000,
         0.3333333333333334, -1.5000000000000000, 3.0000000000000000, -0.8333333333333333],
	[0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000,
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000,
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
         0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 1.0000000000000000]]);

def list_gases(option, opt, value, parser):
    print "Available gases are:"
    for name in list_gas_names():
        print "   %s" % name
    print ""
    sys.exit()



#-------------------------------------------------------------------------------# 
if __name__ == '__main__':
    """
    The main program declares all the possible options first

    That is followed by somme checks that certain things were declared in those
    options that are necessary

    Then there is an if/else that runs either of the two main programs,
    --build-grid or --write-table
    """
    
    print 'Begin build_adaptive_lut.py'
    from optparse import OptionParser, OptionGroup
    usage = "Usage: %prog [options]"
    parser = OptionParser(usage=usage)

    # This program requires a jobName always be defined


    parser.add_option("-j", "--job", action="store", type="string", dest="jobName",
                      default="None",  help="name of the job for file identification")

    group0 = OptionGroup(parser, "Program selection options")
    group0.add_option("-B", "--build-grid", dest ="build_grid_flag",
                      action="store_true", default = False,
                      help="option to build function grid by calling CEA function."\
                      +" see option list: 'Build grid program options'")
    group0.add_option("-w", "--write-table", dest="write_table_flag", 
                      action = "store_true", default = False,
                      help="option to build table by splitting patches - must run build-grid first"\
                      +" see option list: 'Write table program options'")


    group1 = OptionGroup(parser, "Build grid program options")
    group1.add_option("-L", "--max-lr-splits", action="store", dest = "max_lr_splits",
                      default="6",help="Maximum number of permitted subdivisions in"\
                      +"log-rho dimension")
    group1.add_option("-E", "--max-e-splits", action="store", dest = "max_e_splits",
                      default="8",help="Maximum number of permitted subdivisions in"\
                      +"energy dimension")
    group1.add_option("-b", "--bounds", action="store", type="string", dest="bounds",
                      default="200.0,20000.0,-6.0,2.0",
                      help="bounds of the table in form \"T_min,T_max,log_rho_min,log_rho_max\"")
    group1.add_option("-T", "--T-for-offset", action="store", type="string", dest="T_for_offset",
                      default="302.0",
                      help="Temperature (degree K) at which to evaluate the internal energy offset.")

    """
    Second program - write-table program that creates the adaptive look-up table.
    Most of the configuration options have already being selected at this point.
    """
    group2 = OptionGroup(parser, "Write table program options")
    group2.add_option("-I", "--interpolation-method", action="store", type="string", dest="IM",
                      default="bezier",
                      help="Interpolation method for table: bezier or linear. Default is bezier")
    group2.add_option("-e", "--error-method", action="store", type="string", dest="EM",
                      default="maximum",
                      help="Error method for table: maximum or rms. Default is maximum")
    group2.add_option("-p", "--property-errors", action="store", dest="propErrs",
                     help="Select properties to be considered for error limit, and define"\
                     " errors. Properties are Cv_hat, Cv, R_hat, Cp_hat, gamma_hat, mu, k."\
                     " example: --property-errors=\'Cv_hat<1.0e-4,R_hat<1.5e-4,k<0.01\'",
                      default="Cv_hat<1e-3,R_hat<1e-3,gamma_hat<1e-3")
    group2.add_option("-P", "--plot-frequency", action="store", dest="plotFreq",
                     help="Frequency of plotting the tree to 'table_progress' directory"\
                     " during table build.",  default="50")

    # Additional helper functions for gas selection
    group3 = OptionGroup(parser, "Gas selection options")
    group3.add_option("-g", "--gas", action="store", type="string", dest="gasName",
                      help="name of built-in gas mixture")
    group3.add_option("-l", "--list-gases", action="callback", callback=list_gases,
                      help="list available gas names and exit")
    group3.add_option("-c", "--custom", action="store_true", dest="custom", default=False,
                      help="build a custom gas model from reactants")

   
    # Separate set of options for defining a custom gas
    group4 = OptionGroup(parser, "Custom gas options")
    group4.add_option("-r", "--reactants", action="store", type="string", dest="reactants",
                     help="reactant fractions in dictionary form")
    group4.add_option("-o", "--only-list", action="store", type="string", dest="onlyList",
                     help="limit species to this list")
    group4.add_option("-m", "--moles", action="store_const", dest="inputUnits", default="moles", const="moles",
                     help="reactant fractions as mole fractions [default]")
    group4.add_option("-f", "--massf", action="store_const", dest="inputUnits", const="massf",
                     help="reactant fractions as mass fractions")
    group4.add_option("-n", "--no-ions", action="store_false", dest="withIons", default=False,
                     help="excluding ions [default]")
    group4.add_option("-i", "--with-ions", action="store_true", dest="withIons",
                     help="including ions")
       
    parser.add_option_group(group0)
    parser.add_option_group(group1)
    parser.add_option_group(group2)
    parser.add_option_group(group3)
    parser.add_option_group(group4)
    (options, args) = parser.parse_args()

    
    if (options.build_grid_flag == True and (options.gasName == None and not options.custom)):
        print 'Error: Failed to defined a suitable gas object. You can define a'
        print 'a gas by its name, or by custom options.'
        print 'Some examples of how to do this are below.'
        print 'Also see --help option for general help.'
        print ''
        print 'Some examples for function grid options:'
        print ""
        print "Example 1: build_cea_adaptive_lut.py --build-grid --job=air5species --gas=air5species --interpolation-method 'bezier'"
        print "Example 2: build_cea_adaptive_lut.py --build-grid--job=example --custom --reactants=\"N2:0.79,O2:0.21\" --only-list=\"N2,O2,NO,O,N\" "
        print "Example 3: build_cea_adaptive_lut.py --build-grid --job=air-ions --gas=air-ions --bounds=\"500,20000,-6.0,2.0\" --interpolation-method 'linear'"
        print "Example 4: build_cea_adaptive_lut.py --build-grid --job=co2 --gas=co2 --T-for-offset=650.0 --bounds=\"1000.0,20000,-6.0,2.0\""
        print "Example 5: build_cea_adaptive_lut.py --build-grid --job=co2-ions --gas=co2-ions --T-for-offset=1000.0 --bounds=\"1000.0,20000,-6.0,2.0\""
        print ""
        print "Sometimes CEA2 has problems and the table will fail to build."
        print "The best approach to fixing the problem seems to be to raise"
        print "the lower temperatures, as shown in examples 3, 4 and 5 (above)."
        print ""
        sys.exit()
    

    # Store jobName and throw error if it isn't defined
    global jobName
    jobName = options.jobName
    if jobName == 'None':
        print 'ERROR: Must define a job name. Example:'
        print '  $  ./build_cea_adaptive_lut.py --job=air --build-grid'
        sys.exit(1)

    # Declare the recursion limits globally
    global max_lr_splits; global max_e_splits;


    

    ##################### NOW  RUN ONE OF THE TWO PROGRAMS #####################
    
    if options.build_grid_flag == True:
        print '\nRunning program: build-grid. This should take a few hours'

        # Create the gas object
        if options.custom:
            print "Building table for custom gas:"
            print "    reactants=", options.reactants
            print "    inputUnits=", options.inputUnits
            print "    onlyList=", options.onlyList
            print "    withIons=", options.withIons
            if options.reactants == None:
                parser.print_help()
                print "To build a custom gas model, you need to specify reactant fractions"
                print "in dictionary form.  For example: --reactants=\"N2:0.79,O2:0.21\""
                sys.exit()
            reactants = {}
            for species in options.reactants.split(','):
                name, fraction = species.split(':')
                reactants[name] = float(fraction)
            onlyList = []
            if options.onlyList != None:
                for name in options.onlyList.split(','):
                    onlyList.append(name)
            mygas = Gas(reactants, onlyList, options.inputUnits, with_ions=options.withIons)
            gasName = "custom"
        else:
            print "Building table for gas name: ", options.gasName
            mygas = make_gas_from_name(options.gasName)
            gasName = options.gasName  

        # Read the table settings from the command-line options
        max_lr_splits = int(options.max_lr_splits)
        max_e_splits = int(options.max_e_splits)
        T_min, T_max, log_rho_min, log_rho_max = [float(item) for item in options.bounds.split(',')]
        T_for_offset = float(options.T_for_offset)

        # Call the main program to run the function
        build_function_grid(mygas, jobName, max_lr_splits, max_e_splits, T_min,
                             T_max, log_rho_min, log_rho_max, T_for_offset)

        print 'Finished program build-grid'

        
    elif options.write_table_flag == True:
        print '\nRunning program: write-table\n'
        # Read the global parameters from the command line options
        global IM; IM = str(options.IM)
        global EM; EM = str(options.EM)

        print 'Interpolation method:', IM
        print 'Error method:', EM
        global plot_freq; plot_freq = float(options.plotFreq)

        max_lr_splits = int(options.max_lr_splits)
        max_e_splits = int(options.max_e_splits)

        # Set the user-defined error limits
        propErrs = options.propErrs.split(',')
        # Create array for storing the error limits. Properties not considered 
        # will have error_lim=1, and wil always pass the split_test function
        global error_lim; error_lim = numpy.ones((vars))
        for prop in propErrs:
            prop, err = prop.split('<')
            if   prop == 'Cv_hat'   : indx = 0;
            elif prop == 'Cv'       : indx = 1;
            elif prop == 'R_hat'    : indx = 2;
            elif prop == 'Cp_hat'   : indx = 3;
            elif prop == 'gamma_hat': indx = 4;
            elif prop == 'mu'       : indx = 5;
            elif prop == 'k'        : indx = 6;
            else:
                print 'ERROR: In option \'p\' or \'--propert-errors\'.'
                print 'ERROR: Unrecognised property, \'', prop, '\'. Choices are: '
                print 'ERROR: Cv_hat, Cv, R_hat, Cp_hat, gamma_hat, mu, k (without spaces)'
                sys.exit(1)
            error_lim[indx] = float(err)
        print 'Error limits:'
        print ('  Cv_hat: %g Cv: %g R_hat: %g Cp_hat: %g gamma_hat: %g mu: %g k: %g' %
               tuple ([x for x in error_lim]))

        # Load the grid into memory
        global grid; grid = Grid(jobName)
 
        # Build the table and write to file
        write_tree_to_file(jobName)

        print 'Finished program build-grid'


    else:
        print 'ERROR: No valid program option has been chosen. Procedure for',
        print ' building look-up table:'
        print ' 1. Build function grid:'
        print '      $ ./build_cea_adaptive_lut.py --build-grid --job-name=<name> --gas=<gasName>'
        print ' 2. Build adaptive look-up table:'
        print '      $ ./build_cea_adaptive_lut.py --write-table --job-name=<name>'
        print 'Try --help option for full list of features, or see documentation'
        sys.exit(1)
        

  
  

    

